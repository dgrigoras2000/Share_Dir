My apologies for the confusion. If you want to save only the word inside the brackets (excluding the content after the brackets), you can modify the code accordingly. Here's an updated version:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a struct for each node in the list
struct Node {
    char *name;
    char *status;
    struct Node *next;
};

// Function to parse the file and update the list
void parseFileAndUpdateList(const char *filename, const char *keyword, const char *startKeyword, struct Node **head) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("Error opening file.\n");
        return;
    }

    char line[256];
    int saveContent = 0; // Flag to control saving content to the list

    while (fgets(line, sizeof(line), file)) {
        printf("Processing line: %s", line);

        if (line[0] == '[') {
            char *startBracket = strchr(line, '[');
            char *endBracket = strchr(line, ']');

            if (startBracket != NULL && endBracket != NULL && startBracket < endBracket) {
                char *contentStart = startBracket + 1;
                *endBracket = '\0';

                if (strcmp(contentStart, startKeyword) == 0) {
                    saveContent = 1;
                    printf("Start saving content to the list.\n");
                    continue;
                }

                if (saveContent) {
                    // Find the first space or newline character after the bracketed content
                    char *spaceAfterBracket = strpbrk(contentStart, " \n");

                    // Determine the length of the word inside the brackets
                    size_t contentLength = (spaceAfterBracket != NULL)
                        ? (size_t)(spaceAfterBracket - contentStart)
                        : strlen(contentStart);

                    // Check if content is connected from a function
                    int isConnected = strstr(contentStart, "()") != NULL;

                    // Create a new Node
                    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
                    if (newNode != NULL) {
                        // Update the node with dynamically allocated strings
                        newNode->name = (char *)malloc(contentLength + 1);
                        strncpy(newNode->name, contentStart, contentLength);
                        newNode->name[contentLength] = '\0';

                        newNode->status = (char *)malloc(2);
                        snprintf(newNode->status, 2, "%d", isConnected);

                        // Add the node to the list
                        newNode->next = *head;
                        *head = newNode;

                        printf("Added to list: Name: %s, Status: %s\n", newNode->name, newNode->status);
                    } else {
                        printf("Memory allocation error for Node.\n");
                    }

                    saveContent = 0; // Stop saving content after the first word inside brackets
                }
            }
        }
    }

    fclose(file);
}

// Function to print the list
void printList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        printf("Name: %s, Status: %s\n", current->name, current->status);
        current = current->next;
    }
}

// Function to free the memory allocated for the list
void freeList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        struct Node *temp = current;
        current = current->next;
        free(temp->name);
        free(temp->status);
        free(temp);
    }
}

int main() {
    const char *filename = "your_file.txt";
    const char *keyword = "gencards";
    const char *startKeyword = "port1";

    struct Node *head = NULL;

    parseFileAndUpdateList(filename, keyword, startKeyword, &head);

    // Print the list
    printf("\nList contents:\n");
    printList(head);

    // Free the memory allocated for the list
    freeList(head);

    return 0;
}
```

This updated version calculates the length of the word inside the brackets and allocates memory accordingly. It stops saving content after the first word inside brackets, ignoring the rest of the line. Adjust the `filename`, `keyword`, and `startKeyword` as needed for your specific use case.