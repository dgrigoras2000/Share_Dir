Certainly, if the content has an unknown word length, you can use dynamic memory allocation to handle varying lengths. Here's an updated version of the program:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a struct for each node in the list
struct Node {
    char *name;
    char *status;
    struct Node *next;
};

// Function to parse the file and update the list
void parseFileAndUpdateList(const char *filename, const char *keyword, const char *startKeyword, struct Node **head) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("Error opening file.\n");
        return;
    }

    char line[256];
    int saveContent = 0; // Flag to control saving content to the list

    while (fgets(line, sizeof(line), file)) {
        if (line[0] == '[') {
            char *startBracket = strchr(line, '[');
            char *endBracket = strchr(line, ']');

            if (startBracket != NULL && endBracket != NULL && startBracket < endBracket) {
                char *contentStart = startBracket + 1;
                *endBracket = '\0';

                if (strcmp(contentStart, startKeyword) == 0) {
                    saveContent = 1; // Start saving content to the list
                    continue; // Skip adding the current line to the list
                }

                if (saveContent) {
                    // Check if content is connected from a function
                    // For demonstration purposes, assuming it's connected if it contains "()"
                    int isConnected = strstr(contentStart, "()") != NULL;

                    // Create a new Node
                    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
                    if (newNode != NULL) {
                        // Update the node with dynamically allocated strings
                        newNode->name = strdup(contentStart);
                        newNode->status = (char *)malloc(2);
                        snprintf(newNode->status, 2, "%d", isConnected);

                        // Add the node to the list
                        newNode->next = *head;
                        *head = newNode;

                        printf("Added to list: Name: %s, Status: %s\n", newNode->name, newNode->status);
                    } else {
                        printf("Memory allocation error for Node.\n");
                    }
                }
            }
        }
    }

    fclose(file);
}

// Function to print the list
void printList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        printf("Name: %s, Status: %s\n", current->name, current->status);
        current = current->next;
    }
}

// Function to free the memory allocated for the list
void freeList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        struct Node *temp = current;
        current = current->next;
        free(temp->name);
        free(temp->status);
        free(temp);
    }
}

int main() {
    const char *filename = "your_file.txt";
    const char *keyword = "gencards";
    const char *startKeyword = "port1";

    struct Node *head = NULL;

    parseFileAndUpdateList(filename, keyword, startKeyword, &head);

    // Print the list
    printf("\nList contents:\n");
    printList(head);

    // Free the memory allocated for the list
    freeList(head);

    return 0;
}
```

This version uses `strdup` to dynamically allocate memory for the `name` string, allowing for an unknown word length. Adjust the `filename`, `keyword`, and `startKeyword` as needed for your specific use case.